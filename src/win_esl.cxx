// generated by Fast Light User Interface Designer (fluid) version 1.0305

#include "../include/win_esl.h"

void callback_mnu_open() {
  printf("Hello, World!\n");
}

void callback_mnu_save() {
  printf("Hello, World!\n");
}

void callback_mnu_csv_exp() {
  printf("Hello, World!\n");
}

void callback_mnu_csv_imp() {
  printf("Hello, World!\n");
}

void callback_mnu_exit() {
  printf("Hello, World!\n");
}

/**
 Handle drawing table's cells
 Fl_Table calls this function to draw each visible cell in the table.
 It's up to us to use FLTK's drawing functions to draw the cells the way we want.
   //
*/
void MyTable::draw_cell(TableContext context, int R,int C, int X,int Y,int W,int H) {
  static char s[30];
  switch ( context ) {
  	case CONTEXT_STARTPAGE: {			// table about to redraw
  		// Get kb nav + mouse 'selection region' for use below
  		get_selection(s_top, s_left, s_bottom, s_right);
  		break;
  		}

  	case CONTEXT_COL_HEADER: {			// table wants us to draw a column heading (C is column)
  		fl_font(FL_HELVETICA | FL_BOLD, 14);	// set font for heading to bold
  		fl_push_clip(X,Y,W,H);			// clip region for text
  		fl_draw_box(FL_THIN_UP_BOX, X,Y,W,H, col_header_color());

                      if ( C == _sort_lastcol ) {
                          draw_sort_arrow(X,Y,W,H);
                      }


  		fl_color(FL_BLACK);
  		if (C == cols()-1) {			// Last column? show 'TOTAL'
  			fl_draw("TOTAL", X,Y,W,H, FL_ALIGN_CENTER);
  			}
  		else {				// Not last column? show column letter
  			sprintf(s, "%c", 'A' + C);
  			fl_draw(s, X,Y,W,H, FL_ALIGN_CENTER);
  			}

  		fl_pop_clip();
  		return;
  		}

  	case CONTEXT_ROW_HEADER: {			// table wants us to draw a row heading (R is row)
  		fl_font(FL_HELVETICA | FL_BOLD, 14);	// set font for row heading to bold
  		fl_push_clip(X,Y,W,H);
  		fl_draw_box(FL_THIN_UP_BOX, X,Y,W,H, row_header_color());
  		fl_color(FL_BLACK);
  		if (R == rows()-1) {			// Last row? Show 'Total'
  			fl_draw("TOTAL", X,Y,W,H, FL_ALIGN_CENTER);
  			}
  		else {				// Not last row? show row#
  			sprintf(s, "%d", R+1);
  			fl_draw(s, X,Y,W,H, FL_ALIGN_CENTER);
  			}
  		fl_pop_clip();
  		return;
  		}

  		case CONTEXT_CELL: {			// table wants us to draw a cell
  		if (R == row_edit && C == col_edit && input->visible()) {
  			return;					// dont draw for cell with input widget over it
  			}
  		// Background
  		// Keyboard nav and mouse selection highlighting
  		if (R >= s_top && R <= s_bottom && C >= s_left && C <= s_right) {
  			fl_draw_box(FL_THIN_UP_BOX, X,Y,W,H, 0xC6C6C6FF); // Grey
  			}
  		else if ( C < cols()-1 && R < rows()-1 ) {
  			fl_draw_box(FL_THIN_UP_BOX, X,Y,W,H, FL_WHITE);
  			}
  		else {
  			fl_draw_box(FL_THIN_UP_BOX, X,Y,W,H, 0xbbddbb00);	// money green
  			}
  		// Text
  		fl_push_clip(X+3, Y+3, W-6, H-6);

  		fl_color(FL_BLACK);
  		fl_font(FL_HELVETICA, 14);		// ..in regular font
  		sprintf(s, "%d", data[R][C]);
  		fl_draw(s, X+3,Y+3,W-6,H-6, FL_ALIGN_RIGHT);

  		fl_pop_clip();
  		return;
  		}

  	case CONTEXT_RC_RESIZE: {			// table resizing rows or columns
  		if (!input->visible()) {
  			return;
  			}
  		find_cell(CONTEXT_TABLE, row_edit, col_edit, X, Y, W, H);
  		if (X==input->x() && Y==input->y() && W==input->w() && H==input->h()) {
  			return;					// no change? ignore
  			}
  		input->resize(X,Y,W,H);
  		return;
  		}
  	default: {}
  	return;
  	}
}

/**
 table's event callback (instance)
*/
void MyTable::event_callback2() {
  int R = callback_row();
  int C = callback_col();
  TableContext context = callback_context();

  switch ( context ) {
  	case CONTEXT_CELL: {				// A table event occurred on a cell
  		switch (Fl::event()) { 				// see what FLTK event caused it
  			case FL_PUSH: {					// mouse click?
  			done_editing();				// finish editing previous
  			if (R != rows()-1 && C != cols()-1 ) {		// only edit cells not in total's columns
  				start_editing(R,C);				// start new edit
  				}
  			return;
  			}
  			case FL_KEYBOARD: {				// key press in table?
  				if ( Fl::event_key() == FL_Escape ) {exit(0);}	// ESC closes app
  				if (C == cols()-1 || R == rows()-1) {return;}	// no editing of totals column
  				done_editing();				// finish any previous editing
  				set_selection(R, C, R, C);			// select the current cell
  				start_editing(R,C);				// start new edit
  				if (Fl::event() == FL_KEYBOARD && Fl::e_text[0] != '\r') {
  					input->handle(Fl::event());			// pass keypress to input widget
  					}
  				return;
  				}
  			}
  		return;
  		}
  	case CONTEXT_TABLE:					// A table event occurred on dead zone in table
  	case CONTEXT_ROW_HEADER:				// A table event occurred on row/column header
  	case CONTEXT_COL_HEADER:{


  		if ( Fl::event() == FL_RELEASE && (Fl::event_button() == FL_LEFT_MOUSE && Fl::event_clicks() > 0) ) {
  			if ( _sort_lastcol == C ) {   // Click same column? Toggle sort
  				_sort_reverse ^= 1;
  				}
  			else {                        // Click diff column? Up sort
  				_sort_reverse = 0;
  				}
  		//	sort_column(C, _sort_reverse);
  			redraw();
  			_sort_lastcol = C;
  			}
  		done_editing();					// done editing, hide
  		return;
  		}
  	default: {}
  	return;
  	}
}

/**
 // Callback whenever someone clicks on different parts of the table
*/
void MyTable::event_callback(Fl_Widget*,void *v) {
  ((MyTable*)v)->event_callback2();
}

/**
 input widget's callback
*/
void MyTable::input_cb(Fl_Widget*,void* v) {
  ((MyTable*)v)->set_value_hide();
}

/**
 // Draw sort arrow
*/
void MyTable::draw_sort_arrow(int X,int Y,int W,int H) {
  int xlft = X+(W-6)-8;
  int xctr = X+(W-6)-4;
  int xrit = X+(W-6)-0;
  int ytop = Y+(H/2)-4;
  int ybot = Y+(H/2)+4;
  if ( _sort_reverse ) {
  	// Engraved down arrow
  	fl_color(FL_WHITE);
  	fl_line(xrit, ytop, xctr, ybot);
  	fl_color(41);                   // dark gray
  	fl_line(xlft, ytop, xrit, ytop);
  	fl_line(xlft, ytop, xctr, ybot);
  	}
  else {
  	// Engraved up arrow
  	fl_color(FL_WHITE);
  	fl_line(xrit, ybot, xctr, ytop);
  	fl_line(xrit, ybot, xlft, ybot);
  	fl_color(41);                   // dark gray
  	fl_line(xlft, ybot, xctr, ytop);
  	}
}

/**
 Constructor
 Make our data array, and initialize the table options.
*/
MyTable::MyTable(int X, int Y, int W, int H, const char *L) : Fl_Table(X,Y,W,H,L) {
  callback(&event_callback, (void*)this);
  when(FL_WHEN_NOT_CHANGED|when());

  // Create input widget that we'll use whenever user clicks on a cell
  input = new Fl_Int_Input(W/2,H/2,0,0);
  input->hide();
  input->callback(input_cb, (void*)this);
  input->when(FL_WHEN_ENTER_KEY_ALWAYS);		// callback triggered when user hits Enter
  input->maximum_size(5);
  input->color(0x0078D7FF);
  input->textcolor(FL_WHITE);
  input->selection_color(FL_GRAY);

  row_edit = col_edit = 0;
  s_left = s_top = s_right = s_bottom = 0;
  for (int c = 0; c < MAX_COLS; c++) {
  	for (int r = 0; r < MAX_ROWS; r++) {
  		data[r][c] = (r + 2) * (c + 3);		// initialize cells
  		}
  	}

  end();

  _sort_reverse = 0;
  _sort_lastcol = -1;

  // Table rows
  row_header(1);
  row_header_width(70);
  row_resize(1);
  rows(11);
  row_height_all(25);

  // Table cols
  col_header(1);
  col_header_height(25);
  col_resize(1);
  cols(11);
  col_width_all(70);
  set_selection(0,0,0,0);	// select top/left cell
}

/**
 Apply value from input widget to values[row][col] array and hide (done editing)
*/
void MyTable::set_value_hide() {
  data[row_edit][col_edit] = atoi(input->value());
  input->hide();
  window()->cursor(FL_CURSOR_DEFAULT);		// XXX: if we don't do this, cursor can disappear!
}

/**
 Change number of rows
*/
void MyTable::rows(int val) {
  Fl_Table::rows(val);
}

/**
 Change number of columns
*/
void MyTable::cols(int val) {
  Fl_Table::cols(val);
}

/**
 Get number of rows
*/
inline int MyTable::rows() {
  return Fl_Table::rows();
}

/**
 Get number of columns
*/
inline int MyTable::cols() {
  return Fl_Table::cols();
}

/**
 Start editing a new cell: move the Fl_Int_Input widget to specified row/column
 Preload the widget with the cell's current value,
 and make the widget 'appear' at the cell's location.
*/
void MyTable::start_editing(int R, int C) {
  row_edit = R;					// Now editing this row/col
  col_edit = C;
  int X,Y,W,H;
  find_cell(CONTEXT_CELL, R,C, X,Y,W,H);		// Find X/Y/W/H of cell
  input->resize(X,Y,W,H);				// Move Fl_Input widget there
  char s[30]; sprintf(s, "%d", data[R][C]);		// Load input widget with cell's current value
  input->value(s);
  input->position(0,strlen(s));			// Select entire input field
  input->show();					// Show the input widget, now that we've positioned it
  input->take_focus();
}

/**
 Tell the input widget it's done editing, and to 'hide'
*/
void MyTable::done_editing() {
  if (input->visible()) {				// input widget visible, ie. edit in progress?
        set_value_hide();					// Transfer its current contents to cell and hide
      }
}

static void cb_Open(Fl_Menu_*, void*) {
  callback_mnu_open();
}

static void cb_Save(Fl_Menu_*, void*) {
  callback_mnu_save();
}

static void cb_Export(Fl_Menu_*, void*) {
  callback_mnu_csv_exp();
}

static void cb_Import(Fl_Menu_*, void*) {
  callback_mnu_csv_imp();
}

static void cb_Exit(Fl_Menu_*, void*) {
  callback_mnu_exit();
}

Fl_Menu_Item menu_MENU[] = {
 {"File", 0,  0, 0, 64, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"Open", 0,  (Fl_Callback*)cb_Open, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"Save", 0,  (Fl_Callback*)cb_Save, 0, 128, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"Export CSV", 0,  (Fl_Callback*)cb_Export, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"Import CSV", 0,  (Fl_Callback*)cb_Import, 0, 128, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"Exit", 0,  (Fl_Callback*)cb_Exit, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {0,0,0,0,0,0,0,0,0}
};

Fl_Double_Window* win_esl() {
  Fl_Double_Window* w;
  { Fl_Double_Window* o = new Fl_Double_Window(1143, 414, "ESL: Enemy Spawn List Editor");
    w = o; if (w) {/* empty */}
    o->align(Fl_Align(FL_ALIGN_CLIP|FL_ALIGN_INSIDE));
    { MyTable* o = new MyTable(0, 20, 905, 325);
      o->box(FL_THIN_DOWN_FRAME);
      o->color(FL_BACKGROUND_COLOR);
      o->selection_color(FL_BACKGROUND_COLOR);
      o->labeltype(FL_NORMAL_LABEL);
      o->labelfont(0);
      o->labelsize(14);
      o->labelcolor(FL_FOREGROUND_COLOR);
      o->align(Fl_Align(FL_ALIGN_TOP));
      o->when(FL_WHEN_RELEASE);
      o->tooltip("Use keyboard to navigate cells:\n" "Arrow keys or Tab/Shift-Tab");
      o->end();
      Fl_Group::current()->resizable(o);
    } // MyTable* o
    { Fl_Menu_Bar* o = new Fl_Menu_Bar(0, 0, 1500, 20, "MENU");
      o->menu(menu_MENU);
    } // Fl_Menu_Bar* o
    Fl::scheme("gtk+");
    o->icon((char*)LoadIcon(fl_display, MAKEINTRESOURCE(101)));
    Fl::option(Fl::OPTION_ARROW_FOCUS, 1);		// we want arrow keys to navigate table's widgets
    o->end();
  } // Fl_Double_Window* o
  return w;
}
